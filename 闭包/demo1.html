<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    /*
    在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。
    由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。
    而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，
    因此 没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。
    拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，
        以供 bar() 在之后任何时间进行引用。
    bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。
    无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到 闭包。

    */
  function foo() {
      var a=2;
      function bar() {
          console.log(a);
      }
      return bar();
  }
  var baz = foo();
  baz;//闭包的效果
</script>
</body>
</html>